{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = exports.search = exports.get = exports.ImdbError = exports.SearchResults = exports.SearchResult = exports.Game = exports.TVShow = exports.Episode = exports.Movie = exports.Rating = void 0;\nvar ky_universal_1 = __importDefault(require(\"ky-universal\"));\nvar url_search_params_1 = __importDefault(require(\"@ungap/url-search-params\"));\nvar interfaces_1 = require(\"./interfaces\");\nvar omdbapi = new URL(\"https://www.omdbapi.com\");\nfunction isRequestType(reqtype) {\n  if (reqtype === \"movie\" || reqtype === \"series\" || reqtype === \"episode\" || reqtype === \"game\") {\n    return true;\n  }\n  return false;\n}\nfunction reqtoqueryobj(req, apikey, page) {\n  var r = new url_search_params_1.default({\n    apikey: apikey,\n    s: req.name,\n    page: String(page),\n    r: \"json\"\n  });\n  if (req.year !== undefined) {\n    r.append(\"y\", String(req.year));\n  }\n  if (req.reqtype !== undefined) {\n    r.append(\"type\", String(req.reqtype));\n  }\n  return r;\n}\nvar Rating = function () {\n  function Rating(source, value) {\n    this.source = source;\n    this.value = value;\n  }\n  return Rating;\n}();\nexports.Rating = Rating;\nvar Movie = function () {\n  function Movie(obj) {\n    this.ratings = [];\n    this.title = obj.Title;\n    this.year = 0;\n    this._yearData = \"\";\n    if (obj.Year !== undefined) {\n      this._yearData = obj.Year;\n      if (!obj.Year.match(/\\d{4}[-–](?:\\d{4})?/)) {\n        var rawYear = parseInt(obj.Year, 10);\n        if (isNaN(rawYear)) {\n          throw new TypeError(\"invalid year\");\n        }\n        this.year = rawYear;\n      } else {\n        this.year = 0;\n      }\n    }\n    this.rated = obj.Rated;\n    var rawReleased = new Date(obj.Released);\n    if (isNaN(rawReleased.getTime())) {\n      this.released = undefined;\n    } else {\n      this.released = rawReleased;\n    }\n    this.runtime = obj.Runtime;\n    this.genres = obj.Genre;\n    this.director = obj.Director;\n    this.writer = obj.Writer;\n    this.actors = obj.Actors;\n    this.plot = obj.Plot;\n    this.languages = obj.Language;\n    this.country = obj.Country;\n    this.awards = obj.Awards;\n    this.poster = obj.Poster;\n    this.metascore = obj.Metascore;\n    var rawRating = parseFloat(obj.imdbRating);\n    this.rating = isNaN(rawRating) ? 0 : rawRating;\n    this.votes = obj.imdbVotes;\n    this.imdbid = obj.imdbID;\n    this.type = \"episode\";\n    if (obj.Type !== undefined) {\n      if (!isRequestType(obj.Type)) {\n        throw new TypeError(obj.Type + \" is not a valid RequestType\");\n      }\n      this.type = obj.Type;\n    }\n    if (obj.Ratings !== undefined) {\n      for (var _i = 0, _a = obj.Ratings; _i < _a.length; _i++) {\n        var rating = _a[_i];\n        this.ratings.push(new Rating(rating.Source, rating.Value));\n      }\n    }\n    if (obj.DVD !== undefined) {\n      var rawDvd = new Date(obj.DVD);\n      if (isNaN(rawDvd.getTime())) {\n        this.dvd = undefined;\n      } else {\n        this.dvd = rawDvd;\n      }\n    }\n    this.boxoffice = obj.BoxOffice;\n    this.production = obj.Production;\n    this.website = obj.Website;\n    this.name = this.title;\n    this.series = this.type === \"series\";\n    this.imdburl = \"https://www.imdb.com/title/\" + this.imdbid;\n  }\n  return Movie;\n}();\nexports.Movie = Movie;\nvar Episode = function (_super) {\n  __extends(Episode, _super);\n  function Episode(obj, season) {\n    var _this = _super.call(this, obj) || this;\n    if (season !== undefined) {\n      _this.season = season;\n    } else {\n      _this.season = parseInt(obj.Season, 10);\n      if (isNaN(_this.season)) {\n        throw new TypeError(\"invalid season\");\n      }\n    }\n    _this.seriesid = obj.seriesID;\n    if (\"Episode\" in obj) {\n      _this.episode = parseInt(obj.Episode, 10);\n      if (isNaN(_this.episode)) {\n        throw new TypeError(\"invalid episode\");\n      }\n    } else {\n      _this.episode = 0;\n    }\n    return _this;\n  }\n  return Episode;\n}(Movie);\nexports.Episode = Episode;\nvar TVShow = function (_super) {\n  __extends(TVShow, _super);\n  function TVShow(obj, opts) {\n    var _this = _super.call(this, obj) || this;\n    _this._episodes = [];\n    var years = _this._yearData.split(\"-\");\n    _this.start_year = parseInt(years[0], 10);\n    _this.end_year = parseInt(years[1], 10) ? parseInt(years[1], 10) : undefined;\n    _this.totalseasons = parseInt(obj.totalSeasons, 10);\n    _this.opts = opts;\n    if (opts.baseURL && typeof opts.baseURL === \"string\") {\n      opts.baseURL = new URL(opts.baseURL);\n      _this.baseURL = opts.baseURL;\n    } else if (opts.baseURL && opts.baseURL instanceof URL) {\n      _this.baseURL = opts.baseURL;\n    } else {\n      _this.baseURL = omdbapi;\n    }\n    return _this;\n  }\n  TVShow.prototype.episodes = function () {\n    var _this = this;\n    if (this._episodes.length !== 0) {\n      return Promise.resolve(this._episodes);\n    }\n    if (this.opts.apiKey === undefined) {\n      throw new ImdbError(\"Missing api key in opts\");\n    }\n    var funcs = [];\n    for (var i = 1; i <= this.totalseasons; i++) {\n      var qs_1 = new url_search_params_1.default({\n        Season: String(i),\n        apikey: this.opts.apiKey,\n        i: this.imdbid,\n        r: \"json\"\n      });\n      var reqopts = {\n        searchParams: qs_1,\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        timeout: undefined,\n        prefixUrl: this.baseURL\n      };\n      if (this.opts.timeout !== undefined) {\n        reqopts.timeout = this.opts.timeout;\n      }\n      funcs.push(ky_universal_1.default(\"\", reqopts).json());\n    }\n    var prom = Promise.all(funcs).then(function (result) {\n      if (interfaces_1.assertEpisodeSeasonResponse(result)) {\n        return Promise.resolve(result);\n      }\n      return Promise.reject(new TypeError(\"Invalid response from server\"));\n    }).then(function (epData) {\n      var eps = [];\n      for (var _i = 0, epData_1 = epData; _i < epData_1.length; _i++) {\n        var datum = epData_1[_i];\n        if (interfaces_1.isError(datum)) {\n          throw new ImdbError(datum.Error);\n        }\n        var season = parseInt(datum.Season, 10);\n        for (var _a = 0, _b = datum.Episodes; _a < _b.length; _a++) {\n          var ep = _b[_a];\n          eps.push(new Episode(ep, season));\n        }\n      }\n      _this._episodes = eps;\n      return Promise.resolve(eps);\n    });\n    return prom;\n  };\n  return TVShow;\n}(Movie);\nexports.TVShow = TVShow;\nvar Game = function (_super) {\n  __extends(Game, _super);\n  function Game() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return Game;\n}(Movie);\nexports.Game = Game;\nvar SearchResult = function () {\n  function SearchResult(obj) {\n    this.title = obj.Title;\n    this.year = parseInt(obj.Year, 10);\n    this.imdbid = obj.imdbID;\n    if (!isRequestType(obj.Type)) {\n      throw new TypeError(obj.Type + \" is not a valid RequestType\");\n    }\n    this.type = obj.Type;\n    this.poster = obj.Poster;\n    this.name = this.title;\n  }\n  return SearchResult;\n}();\nexports.SearchResult = SearchResult;\nvar SearchResults = function () {\n  function SearchResults(obj, page, opts, req) {\n    this.results = [];\n    this.page = page;\n    this.req = req;\n    this.opts = opts;\n    for (var _i = 0, _a = obj.Search; _i < _a.length; _i++) {\n      var result = _a[_i];\n      this.results.push(new SearchResult(result));\n    }\n    this.totalresults = parseInt(obj.totalResults, 10);\n  }\n  SearchResults.prototype.next = function () {\n    return search(this.req, this.opts, this.page + 1);\n  };\n  return SearchResults;\n}();\nexports.SearchResults = SearchResults;\nvar ImdbError = function () {\n  function ImdbError(message) {\n    this.message = message;\n    this.name = \"imdb api error\";\n  }\n  return ImdbError;\n}();\nexports.ImdbError = ImdbError;\nfunction get(req, opts) {\n  try {\n    return new Client(opts).get(req);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\nexports.get = get;\nfunction search(req, opts, page) {\n  return new Client(opts).search(req, page);\n}\nexports.search = search;\nvar Client = function () {\n  function Client(opts) {\n    if (!Object.prototype.hasOwnProperty.call(opts, \"apiKey\")) {\n      throw new ImdbError(\"Missing api key in opts\");\n    }\n    this.opts = opts;\n    if (opts.baseURL && typeof opts.baseURL === \"string\") {\n      opts.baseURL = new URL(opts.baseURL);\n      this.baseURL = opts.baseURL;\n    } else if (opts.baseURL && opts.baseURL instanceof URL) {\n      this.baseURL = opts.baseURL;\n    } else {\n      this.baseURL = omdbapi;\n    }\n  }\n  Client.prototype.get = function (req, opts) {\n    var mergedOpts = this.mergeOpts(opts);\n    if (mergedOpts.apiKey === undefined) {\n      throw new ImdbError(\"Missing api key in opts\");\n    }\n    var qs = new url_search_params_1.default({\n      apikey: mergedOpts.apiKey,\n      plot: req.short_plot ? \"short\" : \"full\",\n      r: \"json\"\n    });\n    if (req.year !== undefined) {\n      qs.append(\"y\", String(req.year));\n    }\n    if (req.name) {\n      qs.append(\"t\", req.name);\n    } else if (req.id) {\n      qs.append(\"i\", req.id);\n    } else {\n      return Promise.reject(new ImdbError(\"Missing one of req.id or req.name\"));\n    }\n    var reqopts = {\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      searchParams: qs,\n      timeout: undefined,\n      prefixUrl: this.baseURL\n    };\n    if (\"timeout\" in mergedOpts) {\n      reqopts.timeout = mergedOpts.timeout;\n    }\n    var prom = ky_universal_1.default(\"\", reqopts).json().then(function (response) {\n      if (interfaces_1.assertGetResponse(response)) {\n        return Promise.resolve(response);\n      }\n      return Promise.reject(new TypeError(\"Invalid response from server\"));\n    }).then(function (data) {\n      var ret;\n      if (interfaces_1.isError(data)) {\n        throw new ImdbError(data.Error + \": \" + (req.name ? req.name : req.id));\n      }\n      if (interfaces_1.isMovie(data)) {\n        ret = new Movie(data);\n      } else if (interfaces_1.isGame(data)) {\n        ret = new Game(data);\n      } else if (interfaces_1.isTvshow(data)) {\n        ret = new TVShow(data, mergedOpts);\n      } else if (interfaces_1.isEpisode(data)) {\n        ret = new Episode(data);\n      } else {\n        throw new ImdbError(\"type: '\" + data.Type + \"' is not valid\");\n      }\n      return Promise.resolve(ret);\n    });\n    return prom;\n  };\n  Client.prototype.search = function (req, page, opts) {\n    var mergedOpts = this.mergeOpts(opts);\n    if (page === undefined) {\n      page = 1;\n    }\n    if (mergedOpts.apiKey === undefined) {\n      throw new ImdbError(\"Missing api key in opts\");\n    }\n    var qs = reqtoqueryobj(req, mergedOpts.apiKey, page);\n    var reqopts = {\n      searchParams: qs,\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      timeout: undefined,\n      prefixUrl: this.baseURL\n    };\n    if (mergedOpts.timeout) {\n      reqopts.timeout = mergedOpts.timeout;\n    }\n    var prom = ky_universal_1.default(\"\", reqopts).json().then(function (response) {\n      if (interfaces_1.assertSearchResponse(response)) {\n        return Promise.resolve(response);\n      }\n      return Promise.reject(new TypeError(\"Invalid response from server\"));\n    }).then(function (data) {\n      if (interfaces_1.isError(data)) {\n        throw new ImdbError(data.Error + \": \" + req.name);\n      }\n      if (page === undefined) {\n        page = 0;\n      }\n      return Promise.resolve(new SearchResults(data, page, mergedOpts, req));\n    });\n    return prom;\n  };\n  Client.prototype.mergeOpts = function (opts) {\n    if (opts !== undefined) {\n      return __assign(__assign({}, this.opts), opts);\n    }\n    return __assign({}, this.opts);\n  };\n  return Client;\n}();\nexports.Client = Client;","map":{"version":3,"mappings":"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","names":["omdbapi","URL","isRequestType","reqtype","reqtoqueryobj","req","apikey","page","r","url_search_params_1","s","name","String","year","undefined","append","source","value","exports","obj","ratings","title","Title","_yearData","Year","match","rawYear","parseInt","isNaN","TypeError","rated","Rated","rawReleased","Date","Released","getTime","released","runtime","Runtime","genres","Genre","director","Director","writer","Writer","actors","Actors","plot","Plot","languages","Language","country","Country","awards","Awards","poster","Poster","metascore","Metascore","rawRating","parseFloat","imdbRating","rating","votes","imdbVotes","imdbid","imdbID","type","Type","Ratings","_a","_i","push","Rating","Source","Value","DVD","rawDvd","dvd","boxoffice","BoxOffice","production","Production","website","Website","series","imdburl","__extends","season","_super","_this","Season","seriesid","seriesID","episode","Episode","Movie","opts","years","split","start_year","end_year","totalseasons","totalSeasons","baseURL","TVShow","_episodes","length","Promise","resolve","apiKey","ImdbError","funcs","i","qs_1","reqopts","searchParams","headers","timeout","prefixUrl","ky_universal_1","json","prom","all","then","result","interfaces_1","reject","epData","eps","epData_1","datum","Error","_b","Episodes","ep","Search","results","SearchResult","totalresults","totalResults","SearchResults","search","message","get","Client","e","Object","prototype","hasOwnProperty","call","mergedOpts","mergeOpts","qs","short_plot","id","response","data","ret","Game"],"sources":["/Users/vinayyadav/Movies/pnc/node_modules/imdb-api/src/imdb.ts"],"sourcesContent":["import ky from \"ky-universal\";\nimport URLSearchParams from \"@ungap/url-search-params\";\nimport {\n  assertGetResponse,\n  assertSearchResponse,\n  assertEpisodeSeasonResponse,\n  isEpisode,\n  isError,\n  isGame,\n  isMovie,\n  isTvshow,\n  OmdbEpisode,\n  OmdbError,\n  OmdbGetResponse,\n  OmdbSearch,\n  OmdbSearchResult,\n  OmdbSeason,\n  OmdbTvshow,\n} from \"./interfaces\";\n\n/**\n * @hidden\n */\nconst omdbapi = new URL(\"https://www.omdbapi.com\");\n\n/**\n * Options to manipulate movie fetching. These can be passed to {@link get}, {@link search}\n * or the constructor for {@link Client}.\n */\nexport interface MovieOpts {\n  /**\n   * API key for omdbapi. Needed to make any API calls.\n   *\n   * Get one [here](https://www.patreon.com/posts/api-is-going-10743518)\n   */\n  apiKey?: string;\n\n  /**\n   * Timeout in milliseconds to wait before giving up on a request\n   */\n  timeout?: number;\n\n  /**\n   * Base URL to connect to (default: https://www.omdbapi.com)\n   */\n  baseURL?: string | URL;\n}\n\n/**\n * An explicit request for a movie. Does not do searching, this is meant\n * to specify *one* movie.\n *\n * One of {@link name} or {@link id} *MUST* be requested. {@link year} can be used to ensure\n * that the movie you're looking for is selected in the case that there exists\n * more than one movie with the same name.\n *\n * {@link short_plot} can be used to specify whether or not a short or a long plot\n * description is returned with your movie. Default is to return a full plot.\n */\nexport interface MovieRequest {\n  /**\n   * Name of the movie\n   *\n   * Unfortunately, only English names are supported\n   * by omdb at the moment.\n   */\n  name?: string;\n\n  /**\n   * imdb id of the movie\n   */\n  id?: string;\n\n  /**\n   * Year that the movie was released\n   */\n  year?: number;\n\n  /**\n   * Whether or not to request a short plot. Default is full plot.\n   */\n  short_plot?: boolean; // eslint-disable-line camelcase\n}\n\n/**\n * Type of media we're searching for\n */\nexport type RequestType = \"movie\" | \"series\" | \"episode\" | \"game\";\n\nfunction isRequestType(reqtype: string): reqtype is RequestType {\n  if (\n    reqtype === \"movie\" ||\n    reqtype === \"series\" ||\n    reqtype === \"episode\" ||\n    reqtype === \"game\"\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * A search for a movie. This will fetch multiple results based on fuzzy matches\n * for a particular piece of media.\n */\nexport interface SearchRequest {\n  /**\n   * Title of the media that we're looking for. Unfortunately, only English\n   * names are supported by omdb at the moment.\n   */\n  name: string;\n\n  /**\n   * Type of media we're looking for\n   */\n  reqtype?: RequestType;\n\n  /**\n   * Year that the media was released\n   */\n  year?: number;\n}\n\n/**\n * @hidden\n */\nfunction reqtoqueryobj(\n  req: SearchRequest,\n  apikey: string,\n  page: number\n): URLSearchParams {\n  const r = new URLSearchParams({\n    apikey,\n    s: req.name,\n    page: String(page),\n    r: \"json\",\n  });\n\n  if (req.year !== undefined) {\n    r.append(\"y\", String(req.year));\n  }\n\n  if (req.reqtype !== undefined) {\n    r.append(\"type\", String(req.reqtype));\n  }\n\n  return r;\n}\n\n/**\n * Rating for a piece of media.\n */\nexport class Rating {\n  /** Site where the rating came from */\n  public source: string;\n\n  /** Rating that the media got from the @{link Rating.source} */\n  public value: string;\n\n  constructor(source: string, value: string) {\n    this.source = source;\n    this.value = value;\n  }\n}\n\n/**\n * A movie as returned by {@link get}, {@link search}, or any of the methods\n * from {@link Client}. This is not meant to be created directly by consumers of\n * this lib, but instead through querying omdb.\n */\nexport class Movie {\n  /** id of the movie on imdb */\n  public imdbid: string;\n\n  /** direct URL to the movie on imdb */\n  public imdburl: string;\n\n  /** the genres that this movie belongs to */\n  public genres: string;\n\n  /** languages this movie was released in */\n  public languages: string;\n\n  /** countries this movie was released in */\n  public country: string;\n\n  /** votes received on imdb */\n  public votes: string;\n\n  /** whether or not this is a TV series */\n  public series: boolean;\n\n  /** the rating as it appears on imdb */\n  public rating: number;\n\n  /** the runtime of the movie */\n  public runtime: string;\n\n  /** the title of the movie in English */\n  public title: string;\n\n  /** year the movie was released */\n  public year: number;\n\n  /** type of media (see {@link RequestType}) */\n  public type: RequestType;\n\n  /** link to the poster for this movie */\n  public poster: string;\n\n  /** score from a bunch of different review sites */\n  public metascore: string;\n\n  /** the plot (can either be long or short as specified in {@link MovieRequest}) */\n  public plot: string;\n\n  /** what the movie was rated in its country of release */\n  public rated: string;\n\n  /** the directors of the movie */\n  public director: string;\n\n  /** writers of the movie */\n  public writer: string;\n\n  /** leading actors that starred in the movie */\n  public actors: string;\n\n  /** date that the movie was originally released */\n  public released?: Date;\n\n  /** title of the movie */\n  public name: string;\n\n  /** awards won */\n  public awards: string;\n\n  /** website for the movie */\n  public website?: string;\n\n  /** ratings for the media from various sources */\n  public ratings: Rating[];\n\n  /** date of the DVD release */\n  public dvd?: Date;\n\n  /** Production studio */\n  public production?: string;\n\n  /** Box office earnings */\n  public boxoffice?: string;\n\n  /**\n   * @hidden\n   */\n  protected _yearData: string;\n\n  /**\n   * This takes a result from omdb, and transforms it into an\n   * object consumable by customers of imdb-api.\n   *\n   * This isn't meant for direct consumption by API consumers,\n   * and consumers should look at {@link get}, {@link search} or\n   * any of the methods on {@link Client} to get a movie instead.\n   *\n   * @param obj Results from omdb\n   */\n  constructor(obj: OmdbGetResponse) {\n    this.ratings = [];\n\n    this.title = obj.Title;\n\n    this.year = 0;\n    this._yearData = \"\";\n    if (obj.Year !== undefined) {\n      this._yearData = obj.Year;\n      // check for emdash as well\n      if (!obj.Year.match(/\\d{4}[-–](?:\\d{4})?/)) {\n        const rawYear = parseInt(obj.Year, 10);\n        if (isNaN(rawYear)) {\n          throw new TypeError(\"invalid year\");\n        }\n        this.year = rawYear;\n      } else {\n        this.year = 0;\n      }\n    }\n\n    this.rated = obj.Rated;\n\n    const rawReleased = new Date(obj.Released);\n    if (isNaN(rawReleased.getTime())) {\n      this.released = undefined;\n    } else {\n      this.released = rawReleased;\n    }\n\n    this.runtime = obj.Runtime;\n    this.genres = obj.Genre;\n    this.director = obj.Director;\n    this.writer = obj.Writer;\n    this.actors = obj.Actors;\n    this.plot = obj.Plot;\n    this.languages = obj.Language;\n    this.country = obj.Country;\n    this.awards = obj.Awards;\n    this.poster = obj.Poster;\n    this.metascore = obj.Metascore;\n\n    const rawRating = parseFloat(obj.imdbRating);\n    this.rating = isNaN(rawRating) ? 0 : rawRating;\n\n    this.votes = obj.imdbVotes;\n    this.imdbid = obj.imdbID;\n\n    // obj.Type only undefined on episodes\n    this.type = \"episode\";\n    if (obj.Type !== undefined) {\n      if (!isRequestType(obj.Type)) {\n        throw new TypeError(`${obj.Type} is not a valid RequestType`);\n      }\n      this.type = obj.Type;\n    }\n\n    if (obj.Ratings !== undefined) {\n      for (const rating of obj.Ratings) {\n        this.ratings.push(new Rating(rating.Source, rating.Value));\n      }\n    }\n\n    if (obj.DVD !== undefined) {\n      const rawDvd = new Date(obj.DVD);\n      if (isNaN(rawDvd.getTime())) {\n        this.dvd = undefined;\n      } else {\n        this.dvd = rawDvd;\n      }\n    }\n\n    this.boxoffice = obj.BoxOffice;\n    this.production = obj.Production;\n    this.website = obj.Website;\n\n    this.name = this.title;\n    this.series = this.type === \"series\";\n    this.imdburl = `https://www.imdb.com/title/${this.imdbid}`;\n  }\n}\n\n/**\n * An episode as returned by {@link TVShow.episodes}. This is not intended to be\n * instantiated by an API consumer, but instead from results from omdb.\n */\nexport class Episode extends Movie {\n  /** what season this episode is a part of */\n  public season: number;\n\n  /** what number episode in the season this episode is */\n  public episode: number;\n\n  /** what series this episode is a part of (imdbid) */\n  public seriesid: string;\n\n  /**\n   * Creates an epsiode from results from omdb. This is not intended for consumer use.\n   * Please prefer {@link TVShow.epsiodes}.\n   *\n   * @param obj Episodes fetched from omdb\n   * @param season Which season this episode belongs to\n   *\n   * @throws TypeError when the episode number is invalid\n   */\n  constructor(obj: OmdbEpisode, season?: number) {\n    super(obj);\n\n    if (season !== undefined) {\n      this.season = season;\n    } else {\n      this.season = parseInt(obj.Season, 10);\n      if (isNaN(this.season)) {\n        throw new TypeError(\"invalid season\");\n      }\n    }\n\n    this.seriesid = obj.seriesID;\n\n    if (\"Episode\" in obj) {\n      this.episode = parseInt(obj.Episode, 10);\n      if (isNaN(this.episode)) {\n        throw new TypeError(\"invalid episode\");\n      }\n    } else {\n      this.episode = 0;\n    }\n  }\n}\n\n/**\n * A TVShow as returned from {@link get}, {@link search} or any of the methods from\n * {@link Client}. This is not intended to be directly created by consumers of this\n * library\n */\nexport class TVShow extends Movie {\n  /** year this show started */\n  public start_year: number; // eslint-disable-line camelcase\n\n  /** year this show ended if it's ended */\n  public end_year?: number; // eslint-disable-line camelcase\n\n  /** how many seasons this show ran */\n  public totalseasons: number;\n\n  /**\n   * @hidden\n   */\n  private _episodes: Episode[] = [];\n\n  /**\n   * @hidden\n   */\n  private opts: MovieOpts;\n\n  /**\n   * @hidden\n   */\n  private baseURL: URL;\n\n  /**\n   * Creates a new {@link TVShow} from omdb results. This isn't intended to be\n   * used by consumers of this library, instead see {@link get}, {@link search}\n   * or any methods from {@link Client}.\n   *\n   * @param obj The tv show info we got from omdb\n   * @param opts Options that we used to fetch this TVShow, so we can use\n   * them to fetch episodes\n   */\n  constructor(obj: OmdbTvshow, opts: MovieOpts) {\n    super(obj);\n    const years = this._yearData.split(\"-\");\n    this.start_year = parseInt(years[0], 10);\n    this.end_year = parseInt(years[1], 10) ? parseInt(years[1], 10) : undefined;\n    this.totalseasons = parseInt(obj.totalSeasons, 10);\n    this.opts = opts;\n    if (opts.baseURL && typeof opts.baseURL === \"string\") {\n      opts.baseURL = new URL(opts.baseURL);\n      this.baseURL = opts.baseURL;\n    } else if (opts.baseURL && opts.baseURL instanceof URL) {\n      this.baseURL = opts.baseURL;\n    } else {\n      this.baseURL = omdbapi;\n    }\n  }\n\n  /**\n   * Fetches episodes of a TV show\n   *\n   * @return Promise yielding list of episodes\n   */\n  public episodes(): Promise<Episode[]> {\n    if (this._episodes.length !== 0) {\n      return Promise.resolve(this._episodes);\n    }\n\n    if (this.opts.apiKey === undefined) {\n      throw new ImdbError(\"Missing api key in opts\");\n    }\n\n    const funcs = [];\n    for (let i = 1; i <= this.totalseasons; i++) {\n      const qs = new URLSearchParams({\n        Season: String(i),\n        apikey: this.opts.apiKey,\n        i: this.imdbid,\n        r: \"json\",\n      });\n      const reqopts = {\n        searchParams: qs,\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        timeout: undefined as number | undefined,\n        prefixUrl: this.baseURL,\n      };\n\n      if (this.opts.timeout !== undefined) {\n        reqopts.timeout = this.opts.timeout;\n      }\n\n      funcs.push(ky(\"\", reqopts).json());\n    }\n\n    const prom = Promise.all(funcs)\n      .then((result: unknown) => {\n        if (assertEpisodeSeasonResponse(result)) {\n          return Promise.resolve(result);\n        }\n\n        return Promise.reject(new TypeError(\"Invalid response from server\"));\n      })\n      .then((epData: OmdbSeason[] | OmdbError[]) => {\n        const eps: Episode[] = [];\n\n        for (const datum of epData) {\n          if (isError(datum)) {\n            throw new ImdbError(datum.Error);\n          }\n\n          const season = parseInt(datum.Season, 10);\n          for (const ep of datum.Episodes) {\n            eps.push(new Episode(ep, season));\n          }\n        }\n\n        this._episodes = eps;\n\n        return Promise.resolve(eps);\n      });\n\n    return prom;\n  }\n}\n\nexport class Game extends Movie {}\n\n/**\n * A single search result from either {@link search} or {@link Client.search}.\n * This is not intended to be directly created by api consumers.\n */\nexport class SearchResult {\n  /** name of the movie */\n  public title: string;\n\n  /** name of the movie */\n  public name: string;\n\n  /** year the movie was released */\n  public year: number;\n\n  /** imdb id of the movie */\n  public imdbid: string;\n\n  /** type of media we found */\n  public type: RequestType;\n\n  /** link to the poster for this movie */\n  public poster: string;\n\n  constructor(obj: OmdbSearchResult) {\n    this.title = obj.Title;\n    this.year = parseInt(obj.Year, 10);\n    this.imdbid = obj.imdbID;\n\n    if (!isRequestType(obj.Type)) {\n      throw new TypeError(`${obj.Type} is not a valid RequestType`);\n    }\n\n    this.type = obj.Type;\n\n    this.poster = obj.Poster;\n    this.name = this.title;\n  }\n}\n\n/**\n * A single page of {@link SearchResult}s. You can call {@link SearchResults.next} to fetch\n * the next page of results. This is not intended to be created by an API consumer, but instead\n * to be returned by {@link search} or {@link Client.search}.\n */\nexport class SearchResults {\n  public results: SearchResult[] = [];\n\n  public totalresults: number;\n\n  /**\n   * @hidden\n   */\n  private page: number;\n\n  /**\n   * @hidden\n   */\n  private opts: MovieOpts;\n\n  /**\n   * @hidden\n   */\n  private req: SearchRequest;\n\n  /**\n   * Builds a new {@link SearchResults}. Not intended to be called directly by\n   * API consumers, as it only creates the object from omdb results.\n   *\n   * @param obj Search results from omdb\n   * @param page Page number we're fetching\n   * @param opts Stored options from our initial request\n   * @param req A reference to the original request\n   */\n  constructor(\n    obj: OmdbSearch,\n    page: number,\n    opts: MovieOpts,\n    req: SearchRequest\n  ) {\n    this.page = page;\n    this.req = req;\n    this.opts = opts;\n\n    for (const result of obj.Search) {\n      this.results.push(new SearchResult(result));\n    }\n\n    this.totalresults = parseInt(obj.totalResults, 10);\n  }\n\n  /**\n   * Returns the next page of search results\n   *\n   * @return next page of search results\n   */\n  public next(): Promise<SearchResults> {\n    return search(this.req, this.opts, this.page + 1);\n  }\n}\n\nexport class ImdbError {\n  public name = \"imdb api error\";\n\n  constructor(public message: string) {}\n}\n\n/**\n * Fetches a single movie by arbitrary criteria\n *\n * @param req set of requirements to search for\n * @param opts options that modify a search\n *\n * @return a promise yielding a movie\n */\nexport function get(req: MovieRequest, opts: MovieOpts): Promise<Movie> {\n  try {\n    return new Client(opts).get(req);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Searches for a movie by arbitrary criteria\n *\n * @param req set of requirements to search for\n * @param opts options that modify a search\n * @param page page number to return\n *\n * @return a promise yielding search results\n */\nexport function search(\n  req: SearchRequest,\n  opts: MovieOpts,\n  page?: number\n): Promise<SearchResults> {\n  return new Client(opts).search(req, page);\n}\n\n/**\n * A client for fetching imdb information.\n *\n * This is primarly useful for making many requests without having\n * to pass a {@link MovieOpts} object to the same function over and\n * over again.\n *\n * All methods still accept an optional {@link MovieOpts} object in\n * the case that you want to override one or more of the options.\n * These per-method options are merged with the options that are\n * attached to the object, and override the object-local options.\n *\n * ```javascript\n * const cli = new imdb.Client({apiKey: 'xxxxxx', timeout: 30000});\n * cli.get({name: \"The Toxic Avenger\"}).then((movie) => {\n *   console.log(movie.title);\n * });\n *\n * cli.search({name: \"The Toxic Avenger\"}).then((search) => {\n *   for (let result of search.results) {\n *     console.log(result.title);\n *   }\n * });\n * ```\n */\nexport class Client {\n  /**\n   * @hidden\n   */\n  private opts: MovieOpts;\n\n  /**\n   * @hidden\n   */\n  private baseURL: URL;\n\n  /**\n   * Creates a new {@link Client} object.\n   *\n   * @param opts A set of {@link MovieOpts} that will be applied to all\n   * requests made by this object unless overridden.\n   *\n   * @throws {@link ImdbError} if an invalid {@link MovieOpts} is passed\n   */\n  constructor(opts: MovieOpts) {\n    if (!Object.prototype.hasOwnProperty.call(opts, \"apiKey\")) {\n      throw new ImdbError(\"Missing api key in opts\");\n    }\n    this.opts = opts;\n    if (opts.baseURL && typeof opts.baseURL === \"string\") {\n      opts.baseURL = new URL(opts.baseURL);\n      this.baseURL = opts.baseURL;\n    } else if (opts.baseURL && opts.baseURL instanceof URL) {\n      this.baseURL = opts.baseURL;\n    } else {\n      this.baseURL = omdbapi;\n    }\n  }\n\n  /**\n   * Fetches a single movie by arbitrary criteria\n   *\n   * @param req set of requirements to search for\n   * @param opts options that override the {@link Client}'s options\n   *\n   * @return a promise yielding a movie\n   */\n  public get(req: MovieRequest, opts?: MovieOpts): Promise<Movie> {\n    const mergedOpts = this.mergeOpts(opts);\n    if (mergedOpts.apiKey === undefined) {\n      throw new ImdbError(\"Missing api key in opts\");\n    }\n\n    const qs = new URLSearchParams({\n      apikey: mergedOpts.apiKey,\n      plot: req.short_plot ? \"short\" : \"full\",\n      r: \"json\",\n    });\n\n    if (req.year !== undefined) {\n      qs.append(\"y\", String(req.year));\n    }\n\n    if (req.name) {\n      qs.append(\"t\", req.name);\n    } else if (req.id) {\n      qs.append(\"i\", req.id);\n    } else {\n      return Promise.reject(new ImdbError(\"Missing one of req.id or req.name\"));\n    }\n\n    const reqopts = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      searchParams: qs,\n      timeout: undefined as number | undefined,\n      prefixUrl: this.baseURL,\n    };\n\n    if (\"timeout\" in mergedOpts) {\n      reqopts.timeout = mergedOpts.timeout;\n    }\n\n    const prom = ky(\"\", reqopts)\n      .json()\n      .then((response: unknown) => {\n        if (assertGetResponse(response)) {\n          return Promise.resolve(response);\n        }\n\n        return Promise.reject(new TypeError(\"Invalid response from server\"));\n      })\n      .then((data: OmdbGetResponse | OmdbError) => {\n        let ret: Movie | Episode;\n        if (isError(data)) {\n          throw new ImdbError(`${data.Error}: ${req.name ? req.name : req.id}`);\n        }\n\n        if (isMovie(data)) {\n          ret = new Movie(data);\n        } else if (isGame(data)) {\n          ret = new Game(data);\n        } else if (isTvshow(data)) {\n          ret = new TVShow(data, mergedOpts);\n        } else if (isEpisode(data)) {\n          ret = new Episode(data);\n        } else {\n          throw new ImdbError(`type: '${data.Type}' is not valid`);\n        }\n\n        return Promise.resolve(ret);\n      });\n\n    return prom;\n  }\n\n  /**\n   * Searches for a movie by arbitrary criteria\n   *\n   * @param req set of requirements to search for\n   * @param opts options that override the {@link Client}'s options\n   * @param page page number to return\n   *\n   * @return a promise yielding search results\n   */\n  public search(\n    req: SearchRequest,\n    page?: number,\n    opts?: MovieOpts\n  ): Promise<SearchResults> {\n    const mergedOpts = this.mergeOpts(opts);\n    if (page === undefined) {\n      page = 1;\n    }\n\n    if (mergedOpts.apiKey === undefined) {\n      throw new ImdbError(\"Missing api key in opts\");\n    }\n\n    const qs = reqtoqueryobj(req, mergedOpts.apiKey, page);\n    const reqopts = {\n      searchParams: qs,\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      timeout: undefined as number | undefined,\n      prefixUrl: this.baseURL,\n    };\n\n    if (mergedOpts.timeout) {\n      reqopts.timeout = mergedOpts.timeout;\n    }\n\n    const prom = ky(\"\", reqopts)\n      .json()\n      .then((response: unknown) => {\n        if (assertSearchResponse(response)) {\n          return Promise.resolve(response);\n        }\n\n        return Promise.reject(new TypeError(\"Invalid response from server\"));\n      })\n      .then((data: OmdbSearch | OmdbError) => {\n        if (isError(data)) {\n          throw new ImdbError(`${data.Error}: ${req.name}`);\n        }\n\n        if (page === undefined) {\n          page = 0;\n        }\n\n        return Promise.resolve(new SearchResults(data, page, mergedOpts, req));\n      });\n\n    return prom;\n  }\n\n  /**\n   * @hidden\n   */\n  private mergeOpts(opts?: MovieOpts): MovieOpts {\n    if (opts !== undefined) {\n      return { ...this.opts, ...opts };\n    }\n\n    return { ...this.opts };\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}